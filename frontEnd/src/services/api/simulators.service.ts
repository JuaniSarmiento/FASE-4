/**
 * Simulators Service - Simuladores Profesionales (S-IA-X)
 *
 * Refactored to use BaseApiService for consistent API response handling.
 *
 * Session operations (create, get, update, list) delegate to sessionsService
 * since simulator sessions are regular sessions with mode=SIMULATOR.
 */
import { BaseApiService } from './base.service';
import { sessionsService } from './sessions.service';
import { SessionMode } from '@/types/api.types';
import type { SessionResponse } from '@/types/api.types';

export type SimulatorType =
  | 'product_owner'
  | 'scrum_master'
  | 'tech_interviewer'
  | 'incident_responder'
  | 'client'
  | 'devsecops';

export type SimulatorStatus = 'active' | 'development' | 'deprecated';

export interface SimulatorInfo {
  type: SimulatorType;
  name: string;
  description: string;
  competencies: string[];
  status: SimulatorStatus;
  example_questions?: string[];
}

export interface SimulatorInteraction {
  simulator_type: SimulatorType;
  student_input: string;
  context?: Record<string, any>;
}

export interface SimulatorResponse {
  interaction_id: string;
  simulator_type: SimulatorType;
  response: string;
  role: string;
  expects: string[];
  competencies_evaluated: string[];
  trace_id_input: string;
  trace_id_output: string;
  metadata: Record<string, any>;
}

export interface SimulatorSession {
  id: string;
  student_id: string;
  simulator_type: SimulatorType;
  scenario: string;
  created_at: string;
  updated_at: string;
  interactions: SimulatorInteraction[];
  completed: boolean;
  evaluation?: SimulatorEvaluation;
}

export interface SimulatorEvaluation {
  competencies: Record<string, number>;
  overall_score: number;
  strengths: string[];
  improvements: string[];
  professional_readiness: number;
}

/**
 * SimulatorsService - Uses BaseApiService for consistent response handling
 */
class SimulatorsService extends BaseApiService {
  constructor() {
    super('/simulators');
  }

  /**
   * Interact with a simulator
   * Backend route: POST /api/v1/simulators/interact
   * Note: Backend expects session_id and prompt, not student_input
   */
  async interact(sessionId: string, interaction: SimulatorInteraction): Promise<SimulatorResponse> {
    return this.post<SimulatorResponse>('/interact', {
      session_id: sessionId,
      simulator_type: interaction.simulator_type,
      prompt: interaction.student_input,
      context: interaction.context,
    });
  }

  /**
   * Start a simulator session
   * Delegates to sessionsService since simulator sessions are regular sessions
   * with mode=SIMULATOR and simulator_type set.
   */
  async startSession(
    studentId: string,
    simulatorType: SimulatorType,
    activityId: string
  ): Promise<SimulatorSession> {
    // Use sessionsService for consistent session creation
    const session: SessionResponse = await sessionsService.create({
      student_id: studentId,
      activity_id: activityId,
      mode: SessionMode.SIMULATOR,
      simulator_type: simulatorType,
    });

    return this.mapSessionToSimulatorSession(session, simulatorType);
  }

  /**
   * Get simulator session info
   * Delegates to sessionsService for consistent session retrieval.
   */
  async getSession(sessionId: string): Promise<SimulatorSession> {
    const session = await sessionsService.getById(sessionId);
    return this.mapSessionToSimulatorSession(session);
  }

  /**
   * Complete simulator session
   * Delegates to sessionsService.end() for proper session completion.
   * Fetches the evaluation generated by E-IA-Proc after session ends.
   */
  async completeSession(sessionId: string): Promise<SimulatorEvaluation> {
    // Use sessionsService.end() which properly marks session as completed
    await sessionsService.end(sessionId);

    // Try to fetch actual evaluation from evaluations endpoint
    try {
      const { evaluationsService } = await import('./evaluations.service');
      const evaluation = await evaluationsService.getSessionEvaluation(sessionId);

      if (evaluation) {
        // Map EvaluationReport to SimulatorEvaluation
        const competencies: Record<string, number> = {};
        evaluation.dimensions?.forEach((dim) => {
          competencies[dim.dimension] = dim.score;
        });

        return {
          competencies,
          overall_score: evaluation.overall_score || 0,
          strengths: evaluation.key_strengths || [],
          improvements: evaluation.improvement_areas || [],
          professional_readiness: evaluation.ai_dependency_score
            ? Math.round((1 - evaluation.ai_dependency_score) * 100)
            : 0,
        };
      }
    } catch {
      // Evaluation not yet available, return placeholder
    }

    // Fallback if evaluation not available
    return {
      competencies: {},
      overall_score: 0,
      strengths: [],
      improvements: [],
      professional_readiness: 0,
    };
  }

  /**
   * Helper to map SessionResponse to SimulatorSession
   * @private
   */
  private mapSessionToSimulatorSession(
    session: SessionResponse,
    defaultSimulatorType?: SimulatorType
  ): SimulatorSession {
    const simulatorType = (session.simulator_type || defaultSimulatorType || 'product_owner') as SimulatorType;
    return {
      id: session.id,
      student_id: session.student_id,
      simulator_type: simulatorType,
      scenario: '',
      created_at: session.created_at,
      updated_at: session.updated_at,
      interactions: [],
      completed: session.status === 'completed',
    };
  }

  /**
   * Get available simulators (simplified info)
   * Backend route: GET /api/v1/simulators
   * @deprecated Use getAllSimulators() for complete info
   */
  async getAvailableSimulators(): Promise<{ type: SimulatorType; name: string; description: string }[]> {
    // Delegate to getAllSimulators and map to simplified format
    const simulators = await this.getAllSimulators();
    return simulators.map((s) => ({
      type: s.type,
      name: s.name,
      description: s.description,
    }));
  }

  /**
   * Get student's simulator history
   * Delegates to sessionsService.list() and filters by SIMULATOR mode.
   */
  async getStudentHistory(studentId: string): Promise<SimulatorSession[]> {
    try {
      // Use sessionsService for consistent session listing
      const response = await sessionsService.list(studentId);

      // Filter sessions with mode=SIMULATOR and map to SimulatorSession
      const simulatorSessions = (response.data || [])
        .filter((s: SessionResponse) => s.mode === SessionMode.SIMULATOR)
        .map((s: SessionResponse) => this.mapSessionToSimulatorSession(s));

      return simulatorSessions;
    } catch {
      // Return empty array on error to maintain backwards compatibility
      return [];
    }
  }

  /**
   * Get specific simulator info
   * Backend route: GET /api/v1/simulators/{simulator_type}
   */
  async getSimulatorInfo(simulatorType: SimulatorType): Promise<SimulatorInfo> {
    const info = await this.get<any>(`/${simulatorType}`);
    return {
      type: (info.type || '').toLowerCase() as SimulatorType,
      name: info.name,
      description: info.description,
      competencies: info.competencies || [],
      status: info.status || 'active',
      example_questions: info.example_questions,
    };
  }

  /**
   * Get all simulators with full info
   * Backend route: GET /api/v1/simulators
   */
  async getAllSimulators(): Promise<SimulatorInfo[]> {
    const simulators = await this.get<any[]>('');
    if (!Array.isArray(simulators)) return [];
    return simulators.map((s: any) => ({
      type: (s.type || '').toLowerCase() as SimulatorType,
      name: s.name,
      description: s.description,
      competencies: s.competencies || [],
      status: s.status || 'active',
      example_questions: s.example_questions,
    }));
  }
}

export const simulatorsService = new SimulatorsService();